[TOC]

## 排序

| 项目名称 |              项目ID              |
| :------: | :------------------------------: |
| 冒泡排序 | EC6D174178494CEF99B6FC0E99C9ED1A |
| 基数排序 | CD6EA4AE403848708C005A569CA4020A |
|          |                                  |

### 基数排序

#### 时间复杂度

> O (nlog(r)m)，其中r为所采取的基数，而m为堆数

#### 核心思想

```
分配, 回收 -> 分配, 回收 -> 分配, 回收 ...

根据最大值的位数遍历, 每次都会定义一个桶(二维数组[最大值位数][10])
分配 --> 然后遍历需要排序的元素列表, 将元素放在桶内位数对应的位置
回收 --> 再次遍历桶, 由低到高依次获取不为空的桶内元素, 然后放在待排序的元素列表内
一轮的分配回收操作可以使待排序的元素列表按照遍历位数有序
```

#### 使用条件

```
不能包含负数或者0(不能为负数是因为桶内下标为0~9,不能为0是因为桶定义为二维数组,默认为0)

必须要知道最大值(用来确定遍历的次数)
```

### 冒泡排序

#### 时间复杂度

> O(n²)

#### 核心思想

```
比较[arr.length-1]轮, 因为第arr.length-1位的元素会和arr.length的元素比较

每轮内容:
i从0开始, i与i+1比较, 如果i>i+1, 那么就互换 
i不断增加, 直到i<n-1, 一轮下来, 可以让数组元素中最大值排在数组的最后面
```

#### 使用条件

```
不能包含负数或者0(不能为负数是因为桶内下标为0~9,不能为0是因为桶定义为二维数组,默认为0)

必须要知道最大值(用来确定遍历的次数)
```
