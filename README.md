[TOC]

## 排序

| 项目名称 |              项目ID              |
| :------: | :------------------------------: |
| 基数排序 | CD6EA4AE403848708C005A569CA4020A |
| 冒泡排序 | EC6D174178494CEF99B6FC0E99C9ED1A |
| 选择排序 | A7AF0C07AC5147518DF3425179750F3A |
|          |                                  |
|          |                                  |



### 基数排序

#### 时间复杂度

> O (nlog(r)m)，其中r为所采取的基数，而m为堆数

#### 核心思想

```
分配, 回收 -> 分配, 回收 -> 分配, 回收 ...

根据最大值的位数遍历, 每次都会定义一个桶(二维数组[最大值位数][10])
分配 --> 然后遍历需要排序的元素列表, 将元素放在桶内位数对应的位置
回收 --> 再次遍历桶, 由低到高依次获取不为空的桶内元素, 然后放在待排序的元素列表内
一轮的分配回收操作可以使待排序的元素列表按照遍历位数有序
```

#### 使用条件

```
不能包含负数或者0(不能为负数是因为桶内下标为0~9,不能为0是因为桶定义为二维数组,默认为0)

必须要知道最大值(用来确定遍历的次数)
```



### 冒泡排序

#### 时间复杂度

> O(n²)

#### 核心思想

```
比较[arr.length-1]轮, 因为第arr.length-1位的元素会和arr.length的元素比较

每轮内容:
i从0开始, i与i+1比较, 如果i>i+1, 那么就互换 
i不断增加, 直到i<n-1, 一轮下来, 可以让数组元素中最大值排在数组的最后面
```

#### 使用条件

```
暂无
```



### 选择排序

#### 时间复杂度

> O(n²)

#### 核心思想

```
比较[arr.length-1]轮, 因为每轮比较都会将最大值放在最后, 所以最后一次一定是最小的元素

每轮内容:
每轮会将查找的范围缩小1, 每次查找时需要记录最大值的下标, 查询结束后将最大值的下标所对应的元素和查找范围的最后一个元素互换位置
```

#### 使用条件

```
暂无
```



